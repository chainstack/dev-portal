---
title: eth_getLogs | Ronin
openapi: /openapi/ronin_node_api/eth_getLogs.json POST /3997273fc956a67dc6982384500e669e
---

The interactive example is tracking transfers for the [USDC contract](https://app.roninchain.com/address/0x0b7007c13325c48911f73a2dad5fa5dcbf808adc) on the Ronin mainnet.

The `eth_getLogs` method returns an array of logs matching a specified filter object. This is a powerful feature for fetching historical data, such as transactions or events emitted by smart contracts.

<Warning>
### Saigon testnet block range sharding

After the Saigon testnet L1 to L2 migration on February 5, 2026 (block 45,528,550), Chainstack nodes serve two separate backends:

* Blocks 0–45,528,549 — old L1 backend (chain ID `2021`)
* Blocks 45,528,550 onward — new L2 backend (chain ID `202601`)

There is no block overlap. Your `eth_getLogs` calls with `fromBlock` and `toBlock` parameters **must not span block 45,528,550**. Query either the L1 range or the L2 range in a single request—requests that cross the boundary will return incomplete results.

For example, to query the L1 range, set `toBlock` to `0x2B6B5E5` (45,528,549) or earlier. To query the L2 range, set `fromBlock` to `0x2B6B5E6` (45,528,550) or later.
</Warning>

<Check>
**Get you own node endpoint today**

[Start for free](https://console.chainstack.com/) and get your app to production levels immediately. No credit card required.

You can sign up with your GitHub, X, Google, or Microsoft account.
</Check>


## Parameters

* `filter object`: An object with the following fields:
  + `fromBlock` (optional): The block number from which to start fetching logs. In the example, `latest`.
  + `address`: The contract address to fetch the logs from. Example: `0x0b7007c13325c48911f73a2dad5fa5dcbf808adc`.
  + `topics` (optional): An array of topics used to filter the logs. Example: `["0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"]`.

## Response

* `result`: An array of log objects that match the filter criteria.

## Use case

This method is essential for applications that need to retrieve and process historical events emitted by smart contracts, such as token transfers, contract interactions, and other event-driven data.

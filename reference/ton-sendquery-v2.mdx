---
title: sendQuery | TON v2
openapi: "/openapi/ton_node_api/v2/sendQuery.json POST /sendQuery"
---

The `sendQuery` method sends an unpacked external message to the TON blockchain. Unlike [sendBoc](/reference/ton-sendboc-v2) which requires a fully serialized BoC, this method accepts individual message components and constructs the message on the server side.

<Check>
  [Start for free](https://console.chainstack.com/) and get your app to production levels immediately. No credit card required.

  You can sign up with your GitHub, X, Google, or Microsoft account.
</Check>

<Info>
  There's no difference between a full node an archive node in data availability or pricing. All data is always available and all node requests are consumed as 1 request unit.
</Info>

## Request body

* `address` (string, required) — The destination address for the message. Example: `EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs`.
* `body` (string, required) — The body of the message in base64 format.
* `init_code` (string, optional) — The init code in base64 format. Required when deploying a new contract.
* `init_data` (string, optional) — The init data in base64 format. Required when deploying a new contract.

## JSON-RPC

<CodeGroup>
  ```shell shell
  curl -X POST \
    'https://ton-mainnet.core.chainstack.com/f2a2411bce1e54a2658f2710cd7969c3/api/v2/jsonRPC' \
    -H 'Content-Type: application/json' \
    -d '{
      "jsonrpc": "2.0",
      "id": 1,
      "method": "sendQuery",
      "params": {
        "address": "EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs",
        "body": "te6cckEBAQEAAgAAAEysuc0="
      }
    }'
  ```
</CodeGroup>

## Response

* `ok` (boolean) — Whether the operation was successful.

* `result` (object) — The result of the operation. Contains:

  * `@type` (string) — The type of the result, typically `ok` for successful submissions.
  * `@extra` (string) — Extra information about the operation.

## Use case

The `sendQuery` method is useful when you have the message components but haven't serialized them into a BoC:

1. Smart contract deployment when you have separate code and data cells.
2. Simplified transaction sending without manual BoC construction.
3. Testing and debugging with individual message components.
4. Integration with systems that provide message parts separately.

Here's an example of deploying a smart contract using sendQuery:

<CodeGroup>
  ```shell shell
  curl -X 'POST' \
    'https://ton-mainnet.core.chainstack.com/f2a2411bce1e54a2658f2710cd7969c3/api/v2/sendQuery' \
    -H 'accept: application/json' \
    -H 'Content-Type: application/json' \
    -d '{
    "address": "EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs",
    "body": "te6cckEBAQEAAgAAAEysuc0=",
    "init_code": "te6cckEBAQEAXAAAsFF/APSkE/S88sgL...",
    "init_data": "te6cckEBAQEAJAAAQ4AW..."
  }'
  ```
</CodeGroup>

<Tip>
  For most use cases, [sendBoc](/reference/ton-sendboc-v2) or [sendBocReturnHash](/reference/ton-sendbocreturnhash-v2) are preferred as they give you full control over the message serialization. Use `sendQuery` when working with systems that provide unpacked message components.
</Tip>

---
title: userRateLimit | Hyperliquid info
openapi: /openapi/hyperliquid_node_api/info_userratelimit.json post /4f8d8f4040bdacd1577bff8058438274/info
---

<Info>
This method is available on Chainstack. Not all Hyperliquid methods are available — see [Hyperliquid methods](/docs/hyperliquid-methods) for the full availability breakdown.
</Info>

The `info` endpoint with `type: "userRateLimit"` retrieves detailed information about a user's API rate limit configuration and current usage on the Hyperliquid exchange. This endpoint provides essential information for managing API usage, avoiding rate limiting, and optimizing request patterns for high-frequency applications.

<Check>
**Get your own node endpoint today**

[Start for free](https://console.chainstack.com/) and get your app to production levels immediately. No credit card required.

You can sign up with your GitHub, X, Google, or Microsoft account.
</Check>

## Parameters

### Request body

* `type` (string, required) — The request type. Must be `"userRateLimit"` to retrieve user's rate limit information.
* `user` (string, required) — Address in 42-character hexadecimal format (e.g., `0x31ca8395cf837de08b24da3f660e77761dfb974b`).

## Response

The response is an object containing comprehensive rate limit information for the user:

### Rate limit configuration

* `userAddress` (string) — Address of the user (matches the requested user)
* `rateLimitTier` (string) — Rate limit tier assigned to the user:
  * `"standard"` — Basic rate limits for regular users
  * `"premium"` — Enhanced limits for active traders
  * `"vip"` — Highest limits for institutional or high-volume users

### Limit specifications

* `requestsPerSecond` (integer, optional) — Maximum allowed requests per second
* `requestsPerMinute` (integer, optional) — Maximum allowed requests per minute
* `requestsPerHour` (integer, optional) — Maximum allowed requests per hour
* `burstLimit` (integer, optional) — Maximum burst requests allowed in short periods

### Current usage tracking

* `currentUsage` (object, optional) — Real-time API usage statistics:
  * `requestsLastSecond` (integer) — Number of requests made in the last second
  * `requestsLastMinute` (integer) — Number of requests made in the last minute
  * `requestsLastHour` (integer) — Number of requests made in the last hour

### Reset timing

* `resetTimes` (object, optional) — When rate limit counters reset:
  * `nextSecondReset` (integer) — Timestamp when per-second counter resets (milliseconds)
  * `nextMinuteReset` (integer) — Timestamp when per-minute counter resets (milliseconds)
  * `nextHourReset` (integer) — Timestamp when per-hour counter resets (milliseconds)

### Status information

* `isThrottled` (boolean, optional) — Whether the user is currently being rate limited
* `upgradeAvailable` (boolean, optional) — Whether higher rate limit tiers are available

### Understanding rate limits

**Rate limit tiers:**
- **Standard**: Basic limits suitable for manual trading and light automation
- **Premium**: Enhanced limits for active algorithmic trading
- **VIP**: Highest limits for institutional users and market makers

**Time windows:**
- **Per-second**: Short-term burst protection
- **Per-minute**: Medium-term usage control
- **Per-hour**: Long-term usage management

**Usage optimization:**
- Monitor current usage to stay within limits
- Implement backoff strategies when approaching limits
- Use reset times to optimize request timing
- Consider rate limit upgrades for high-frequency needs

## Example request

```shell Shell
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"type": "userRateLimit", "user": "0x31ca8395cf837de08b24da3f660e77761dfb974b"}' \
  https://hyperliquid-mainnet.core.chainstack.com/4f8d8f4040bdacd1577bff8058438274/info
```

## Use case

The `info` endpoint with `type: "userRateLimit"` is essential for applications that need to:

* **API usage optimization**: Monitor and optimize API request patterns to avoid rate limiting
* **Request scheduling**: Plan API calls based on current usage and reset times
* **Error handling**: Implement proper backoff strategies when rate limits are reached
* **Performance monitoring**: Track API usage patterns and identify optimization opportunities
* **Capacity planning**: Understand rate limit constraints for application design
* **Automated trading**: Ensure trading bots operate within API usage limits
* **High-frequency systems**: Optimize request timing for maximum throughput
* **Usage dashboards**: Display real-time API usage and remaining capacity
* **Tier management**: Monitor rate limit tier status and upgrade availability
* **Compliance monitoring**: Ensure applications stay within assigned usage limits
* **Load balancing**: Distribute API calls across time windows to maximize usage
* **System health**: Monitor for rate limiting issues in production systems
* **Development planning**: Design applications with rate limit considerations
* **Cost optimization**: Balance API usage with performance requirements

This endpoint is particularly valuable for algorithmic trading systems, high-frequency applications, and any automated system that makes frequent API calls to the Hyperliquid exchange. It enables proactive rate limit management and helps prevent service disruptions due to API throttling.

---
title: trace_call | Hyperliquid EVM
openapi: /openapi/hyperliquid_node_api/evm_trace_call.json post /evm
---

The `trace_call` JSON-RPC method executes a call and returns trace information using OpenEthereum-style tracing. This method simulates a transaction and provides detailed execution traces without committing changes to the blockchain, making it ideal for transaction analysis, debugging, and testing before actual execution.

<Check>
**Get your own node endpoint today**

[Start for free](https://console.chainstack.com/) and get your app to production levels immediately. No credit card required.

You can sign up with your GitHub, X, Google, or Microsoft account.
</Check>

## Parameters

1. **Call object** (object, required): Transaction call details
2. **Trace types** (array, required): Array of trace types to include
3. **Block parameter** (string, required): Block number, hash, or "latest"/"earliest"/"pending"

### Call object structure

- `from` (string, optional): Address the transaction is sent from
- `to` (string, required): Address the transaction is directed to
- `gas` (string, optional): Gas provided for transaction execution
- `gasPrice` (string, optional): Gas price for the transaction
- `value` (string, optional): Value sent with the transaction
- `data` (string, optional): Hash of the method signature and encoded parameters

### Trace types

- `"trace"`: Basic execution trace information
- `"vmTrace"`: Virtual machine execution trace
- `"stateDiff"`: State differences caused by the transaction

## Response

The method returns an array of trace objects containing detailed execution information.

### Response structure

**Trace objects:**
- `action` — Details about the call action (from, to, value, gas, input, callType)
- `result` — Execution result (gasUsed, output)
- `traceAddress` — Address path within the call hierarchy
- `type` — Type of trace (call, create, suicide, etc.)

## Usage example

### Basic implementation

```javascript
// Execute a traced call
const traceCall = async (callObject, traceTypes = ['trace'], blockParam = 'latest') => {
  const response = await fetch('https://hyperliquid-mainnet.core.chainstack.com/YOUR_ENDPOINT/evm', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      jsonrpc: '2.0',
      method: 'trace_call',
      params: [callObject, traceTypes, blockParam],
      id: 1
    })
  });
  
  const data = await response.json();
  return data.result;
};

// Analyze contract interaction
const analyzeContractCall = async () => {
  const callObject = {
    from: '0x69835D480110e4919B7899f465aAB101e21c8A87',
    to: '0xB7C609cFfa0e47DB2467ea03fF3e598bf59361A5',
    gas: '0x76c0',
    gasPrice: '0x9184e72a000',
    value: '0xde0b6b3a7640000',
    data: '0x'
  };

  const traces = await traceCall(callObject);
  
  console.log('Execution Trace Analysis:');
  traces.forEach((trace, index) => {
    console.log(`Trace ${index + 1}:`);
    console.log(`  Type: ${trace.type}`);
    console.log(`  From: ${trace.action.from}`);
    console.log(`  To: ${trace.action.to}`);
    console.log(`  Gas Used: ${parseInt(trace.result.gasUsed, 16)}`);
    console.log(`  Call Type: ${trace.action.callType}`);
  });
  
  return traces;
};

// Usage
analyzeContractCall().then(traces => {
  console.log('Analysis completed');
});
```

## Example request

```shell Shell
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "trace_call",
    "params": [
      {
        "from": "0x69835D480110e4919B7899f465aAB101e21c8A87",
        "to": "0xB7C609cFfa0e47DB2467ea03fF3e598bf59361A5",
        "gas": "0x76c0",
        "gasPrice": "0x9184e72a000",
        "value": "0xde0b6b3a7640000",
        "data": "0x"
      },
      ["trace"],
      "latest"
    ],
    "id": 1
  }' \
  https://hyperliquid-mainnet.core.chainstack.com/4f8d8f4040bdacd1577bff8058438274/evm
```

## Use cases

The `trace_call` method is essential for applications that need to:

* **Transaction simulation**: Simulate transactions before execution to predict outcomes
* **Gas estimation**: Get accurate gas estimates for complex contract interactions
* **Debugging tools**: Debug smart contract execution and identify issues
* **Security analysis**: Analyze potential security vulnerabilities in contract calls
* **DeFi testing**: Test complex DeFi operations before execution
* **MEV analysis**: Analyze Maximum Extractable Value opportunities
* **Development workflows**: Integrate simulation into development pipelines
* **User interfaces**: Provide transaction previews in user applications
* **Risk assessment**: Assess risks before executing high-value transactions
* **Compliance checking**: Verify regulatory compliance before transaction execution
* **Educational tools**: Create educational content about transaction execution
* **Research platforms**: Support blockchain research and analysis
* **Performance optimization**: Optimize contract interactions for better efficiency
* **Integration testing**: Test smart contract integrations thoroughly
* **Protocol development**: Develop and test new blockchain protocols

This method provides comprehensive transaction simulation capabilities with detailed execution traces, enabling thorough analysis and testing on the Hyperliquid EVM platform.
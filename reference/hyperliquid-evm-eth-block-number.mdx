---
title: eth_blockNumber | Hyperliquid EVM
openapi: /openapi/hyperliquid_node_api/evm_eth_block_number.json post /evm
---

The `eth_blockNumber` JSON-RPC method returns the number of the most recent block on the Hyperliquid EVM blockchain. This method is fundamental for tracking blockchain state, monitoring synchronization status, and implementing block-based logic in applications.

<Check>
**Get your own node endpoint today**

[Start for free](https://console.chainstack.com/) and get your app to production levels immediately. No credit card required.

You can sign up with your GitHub, X, Google, or Microsoft account.
</Check>

## Parameters

This method takes no parameters. The `params` field should be an empty array.

## Response

The method returns the current block number as a hexadecimal string.

### Response structure

**Block information:**
- `result` â€” The current block number as a hexadecimal string (e.g., "0x1b4" which equals 436 in decimal)

### Block number interpretation

**Hexadecimal format:**
- Block numbers are returned in hexadecimal format with "0x" prefix
- Convert to decimal for human-readable block height
- Example: "0x1b4" = 436 in decimal

**Usage patterns:**
- Track blockchain progression and new block creation
- Implement block-based polling and event detection
- Verify synchronization status with other nodes
- Calculate block intervals and timing

## Usage example

### Basic implementation

```javascript
// Get current block number
const getCurrentBlockNumber = async () => {
  const response = await fetch('https://hyperliquid-mainnet.core.chainstack.com/YOUR_ENDPOINT/evm', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      jsonrpc: '2.0',
      method: 'eth_blockNumber',
      params: [],
      id: 1
    })
  });
  
  const data = await response.json();
  const blockNumber = parseInt(data.result, 16);
  
  return {
    hex: data.result,
    decimal: blockNumber
  };
};

// Poll for new blocks
const pollForNewBlocks = async (callback) => {
  let lastBlockNumber = 0;
  
  const checkForNewBlock = async () => {
    try {
      const { decimal: currentBlock } = await getCurrentBlockNumber();
      
      if (currentBlock > lastBlockNumber) {
        lastBlockNumber = currentBlock;
        callback(currentBlock);
      }
    } catch (error) {
      console.error('Error checking block number:', error);
    }
  };
  
  // Poll every 2 seconds
  setInterval(checkForNewBlock, 2000);
};

// Usage
pollForNewBlocks((blockNumber) => {
  console.log(`New block: ${blockNumber}`);
});
```

## Example request

```shell Shell
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}' \
  https://hyperliquid-mainnet.core.chainstack.com/4f8d8f4040bdacd1577bff8058438274/evm
```

## Use cases

The `eth_blockNumber` method is essential for applications that need to:

* **Blockchain monitoring**: Monitor blockchain health, synchronization, and block progression
* **Event detection**: Implement efficient event detection and monitoring systems
* **Transaction tracking**: Track transaction confirmations and finality status
* **Synchronization verification**: Verify node synchronization and detect lag issues
* **Block-based logic**: Implement application logic that depends on block heights
* **Performance monitoring**: Monitor network performance and block creation times
* **Data consistency**: Ensure data consistency across blockchain state changes
* **Polling optimization**: Implement efficient polling mechanisms for blockchain data
* **Cache management**: Manage cache invalidation and data freshness using block numbers
* **Analytics platforms**: Build analytics tools that track blockchain metrics over time
* **Trading applications**: Implement trading logic that depends on block timing
* **DeFi protocols**: Build DeFi applications with block-aware functionality
* **NFT platforms**: Track NFT transactions and state changes across blocks
* **Gaming applications**: Implement blockchain-based gaming with block-dependent mechanics
* **Oracle services**: Provide block-aware oracle data and timing services
* **Cross-chain bridges**: Coordinate cross-chain operations using block numbers
* **Governance systems**: Implement governance mechanisms with block-based voting periods
* **Staking protocols**: Track staking rewards and penalties across block intervals
* **Audit tools**: Build audit tools that analyze blockchain state across blocks
* **Development frameworks**: Create development tools with block-aware debugging
* **Testing suites**: Implement blockchain testing with block progression simulation
* **Load balancers**: Distribute load based on node synchronization status
* **Health checks**: Monitor node health and blockchain connectivity
* **Alerting systems**: Create alerts based on block progression and timing anomalies

This method provides fundamental blockchain state information, enabling robust and block-aware applications on the Hyperliquid EVM platform.
---
title: eth_getTransactionByBlockNumberAndIndex | Hyperliquid EVM
openapi: /openapi/hyperliquid_node_api/evm_eth_get_transaction_by_block_number_and_index.json post /evm
---

The `eth_getTransactionByBlockNumberAndIndex` JSON-RPC method returns transaction information by block number and transaction index. This method is ideal for sequential transaction processing and building comprehensive blockchain datasets when working with block numbers.

<Check>
**Get your own node endpoint today**

[Start for free](https://console.chainstack.com/) and get your app to production levels immediately. No credit card required.

You can sign up with your GitHub, X, Google, or Microsoft account.
</Check>

## Parameters

The method takes two parameters:

1. **Block number** - The number of the block containing the transaction
2. **Transaction index** - The index position of the transaction within the block

### Parameter details

* `blockNumber` (string, required) — Block identifier: `"latest"`, `"earliest"`, `"pending"`, or a specific block number in hexadecimal
* `transactionIndex` (string, required) — The index position of the transaction in the block as a hexadecimal string (0-based)

## Response

The method returns detailed transaction information, or `null` if the transaction is not found.

### Response structure

**Transaction object:**
- `hash` — The 32-byte transaction hash
- `nonce` — Transaction nonce (number of transactions sent by sender)
- `blockHash` — Hash of the block containing the transaction
- `blockNumber` — Number of the block containing the transaction
- `transactionIndex` — Index of the transaction in the block
- `from` — Address of the transaction sender
- `to` — Address of the transaction receiver (null for contract creation)
- `value` — Value transferred in wei as a hexadecimal string
- `gas` — Gas limit provided by the sender
- `gasPrice` — Gas price provided by the sender in wei
- `input` — Data sent along with the transaction
- `v`, `r`, `s` — ECDSA signature components
- `type` — Transaction type (0x0 for legacy, 0x1 for EIP-2930, 0x2 for EIP-1559)

### Block number formats

**Special identifiers:**
- `"latest"` — Most recent block's transactions
- `"earliest"` — Genesis block transactions (usually none)
- `"pending"` — Pending block transactions

**Hexadecimal numbers:**
- `"0x0"` — Genesis block
- `"0x9d0c37"` — Block 10,291,255 (decimal)

## Sequential processing

### Range-based analysis

**Block range processing:**
- Process transactions across multiple consecutive blocks
- Build comprehensive transaction datasets systematically
- Analyze transaction patterns over time periods
- Generate time-series transaction analytics

**Chronological analysis:**
- Process transactions in chronological order
- Track transaction evolution and patterns over time
- Build historical transaction databases
- Analyze network activity trends and cycles

### Efficient iteration

**Block-by-block processing:**
- Iterate through blocks sequentially using block numbers
- Process all transactions within each block systematically
- Maintain transaction order and block context
- Build complete blockchain transaction datasets

**Parallel processing:**
- Process multiple blocks concurrently for efficiency
- Distribute transaction processing across workers
- Optimize throughput for large-scale analysis
- Balance load across processing resources

## Development patterns

### Systematic data collection

**Complete blockchain analysis:**
- Process all transactions from genesis to latest block
- Build comprehensive transaction databases
- Generate complete network activity statistics
- Create historical blockchain datasets

**Incremental processing:**
- Process new blocks as they are mined
- Maintain up-to-date transaction datasets
- Implement efficient incremental updates
- Handle real-time transaction processing

### Transaction indexing

**Index-based retrieval:**
- Build transaction indexes based on block position
- Enable efficient transaction lookup by position
- Maintain transaction ordering within blocks
- Optimize for sequential access patterns

**Batch processing:**
- Process multiple transactions from the same block
- Optimize API usage and network efficiency
- Implement efficient batch processing workflows
- Reduce overhead for bulk operations

## Integration strategies

### Analytics platforms

**Time-series analysis:**
- Analyze transaction patterns over time using block numbers
- Build time-based transaction metrics and KPIs
- Generate historical transaction reports
- Create transaction trend analysis systems

**Network monitoring:**
- Monitor transaction activity in real-time using latest blocks
- Track network utilization and capacity metrics
- Generate network health indicators
- Build transaction-based alerting systems

### Block explorers

**Sequential navigation:**
- Enable navigation through blocks using block numbers
- Display transactions in chronological order
- Provide block-based transaction browsing
- Show transaction context within block sequences

**Historical exploration:**
- Browse historical transactions using block numbers
- Provide time-based transaction search capabilities
- Enable exploration of transaction history
- Show transaction evolution over time

## Transaction processing workflows

### Real-time monitoring

**Latest block processing:**
```javascript
// Process transactions from latest block
const processLatestTransactions = async () => {
  const txCount = await getBlockTransactionCount("latest");
  
  for (let i = 0; i < parseInt(txCount, 16); i++) {
    const tx = await getTransactionByBlockNumberAndIndex("latest", `0x${i.toString(16)}`);
    if (tx) {
      await processTransaction(tx);
    }
  }
};
```

**Block range processing:**
```javascript
// Process transactions across block range
const processBlockRange = async (startBlock, endBlock) => {
  for (let blockNum = startBlock; blockNum <= endBlock; blockNum++) {
    const hexBlock = `0x${blockNum.toString(16)}`;
    const txCount = await getBlockTransactionCount(hexBlock);
    
    for (let i = 0; i < parseInt(txCount, 16); i++) {
      const tx = await getTransactionByBlockNumberAndIndex(hexBlock, `0x${i.toString(16)}`);
      if (tx) {
        await processTransaction(tx);
      }
    }
  }
};
```

### Data analysis patterns

**Transaction metrics:**
```javascript
// Calculate block-level transaction metrics
const analyzeBlockTransactions = async (blockNumber) => {
  const txCount = await getBlockTransactionCount(blockNumber);
  const transactions = [];
  
  for (let i = 0; i < parseInt(txCount, 16); i++) {
    const tx = await getTransactionByBlockNumberAndIndex(blockNumber, `0x${i.toString(16)}`);
    if (tx) transactions.push(tx);
  }
  
  return {
    count: transactions.length,
    totalValue: transactions.reduce((sum, tx) => sum + parseInt(tx.value, 16), 0),
    avgGasPrice: transactions.reduce((sum, tx) => sum + parseInt(tx.gasPrice, 16), 0) / transactions.length,
    contractCalls: transactions.filter(tx => tx.input !== "0x").length
  };
};
```

## Example request

```shell Shell
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"jsonrpc":"2.0","method":"eth_getTransactionByBlockNumberAndIndex","params":["0x9d0c37","0x0"],"id":1}' \
  https://hyperliquid-mainnet.core.chainstack.com/4f8d8f4040bdacd1577bff8058438274/evm
```

## Use cases

The `eth_getTransactionByBlockNumberAndIndex` method is essential for applications that need to:

* **Sequential processing**: Process transactions across block ranges systematically
* **Time-series analysis**: Analyze transaction patterns over time using block numbers
* **Blockchain synchronization**: Build and maintain synchronized blockchain datasets
* **Analytics platforms**: Collect comprehensive transaction data for analysis
* **Block explorers**: Display transactions in chronological block order
* **Historical analysis**: Study transaction evolution and network growth patterns
* **Data archival**: Archive transaction data with proper temporal context
* **Network monitoring**: Track transaction activity and network utilization over time
* **Research platforms**: Study blockchain behavior and transaction patterns
* **Audit systems**: Verify transaction sequences and blockchain integrity
* **Development tools**: Debug and test applications with historical transaction data
* **Compliance monitoring**: Track transactions for regulatory compliance over time
* **Performance analysis**: Analyze network performance and transaction throughput
* **Integration services**: Provide chronological transaction data to external systems
* **Educational platforms**: Demonstrate blockchain concepts using real transaction data
* **Forensic analysis**: Investigate transaction patterns and blockchain activities
* **Risk management**: Analyze transaction risks and patterns over time periods
* **Portfolio tracking**: Track user transactions across multiple blocks chronologically
* **DeFi analytics**: Analyze DeFi protocol activity and usage patterns over time
* **Market analysis**: Study trading activity and market behavior using transaction data
* **MEV research**: Analyze maximal extractable value patterns across blocks
* **Network economics**: Study transaction fees and network economics over time
* **Chain analysis**: Analyze blockchain structure and transaction relationships
* **Security monitoring**: Monitor suspicious activities across block ranges
* **Data visualization**: Create time-based charts and graphs of transaction activity

This method provides efficient sequential transaction access by block number, enabling comprehensive time-based analysis on the Hyperliquid EVM platform.

<Note>
This method supports special block identifiers like `"latest"` and `"pending"`, making it suitable for both historical analysis and real-time transaction monitoring.
</Note>
---
title: eth_callMany | Hyperliquid EVM
openapi: /openapi/hyperliquid_node_api/evm_eth_call_many.json post /evm
---

The `eth_callMany` JSON-RPC method executes multiple call transactions in sequence without creating transactions on the blockchain. This method is useful for batch reading contract states and simulating multiple contract interactions efficiently.

<Check>
**Get your own node endpoint today**

[Start for free](https://console.chainstack.com/) and get your app to production levels immediately. No credit card required.

You can sign up with your GitHub, X, Google, or Microsoft account.
</Check>

## Parameters

The method takes two parameters:

1. **Array of call context objects** — Contains transactions to execute
2. **Block state object** — The block state for execution

### Parameter details

**Call context array:**
Each object in the array contains:
* `transactions` (array, required) — Array of transaction objects to execute
  * `to` (string, required) — The address to call
  * `data` (string, optional) — The data to send with the call
  * `from` (string, optional) — The address the call is made from
  * `gas` (string, optional) — The gas limit for the call
  * `gasPrice` (string, optional) — The gas price for the call
  * `value` (string, optional) — The value to send with the call

**Block state object:**
* `blockNumber` (string, required) — Block identifier (e.g., "latest", or specific block number)

## Response

The method returns an array of results corresponding to each call.

### Response structure

**Results array:**
- Array of hexadecimal strings, each representing the return data from the corresponding call
- Results maintain the same order as the input calls
- Failed calls return `0x` or an error

## Example request

```shell Shell
curl -X POST https://hyperliquid-mainnet.core.chainstack.com/4f8d8f4040bdacd1577bff8058438274/evm \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "method": "eth_callMany",
    "params": [
      [
        {
          "transactions": [
            {
              "to": "0x5555555555555555555555555555555555555555",
              "data": "0x70a082310000000000000000000000008D25Fb438C6efCD08679ffA82766869B50E24608"
            },
            {
              "to": "0xb8ce59fc3717ada4c02eadf9682a9e934f625ebb",
              "data": "0x70a082310000000000000000000000008D25Fb438C6efCD08679ffA82766869B50E24608"
            }
          ]
        }
      ],
      {
        "blockNumber": "latest"
      }
    ],
    "id": 1
  }'
```

## Use cases

The `eth_callMany` method is essential for applications that need to:

* **Batch read operations**: Read multiple contract states in a single request
* **DeFi dashboards**: Fetch multiple token balances and positions efficiently
* **Portfolio trackers**: Query multiple asset positions simultaneously
* **Smart contract testing**: Simulate multiple contract interactions
* **Data aggregation**: Collect data from multiple sources in one call
* **Price oracles**: Fetch prices from multiple oracle contracts
* **Multi-token operations**: Check balances across multiple tokens
* **Protocol monitoring**: Monitor multiple protocol states
* **Wallet applications**: Display multiple asset balances
* **Analytics platforms**: Gather multiple metrics efficiently
* **DEX interfaces**: Query multiple pool states
* **Lending protocols**: Check multiple collateral positions
* **Yield aggregators**: Compare yields across protocols
* **NFT marketplaces**: Query multiple NFT metadata
* **Governance systems**: Check voting power across proposals
* **Cross-protocol queries**: Interact with multiple protocols
* **Risk assessment**: Evaluate multiple risk parameters
* **Audit tools**: Verify multiple contract states
* **Development tools**: Debug multiple contract calls
* **Integration services**: Provide batched API endpoints

This method provides efficient batch execution capabilities for read-only operations on the Hyperliquid EVM platform.

<Note>
The `eth_callMany` method executes calls sequentially in the order provided. Each call can see the state changes from previous calls in the batch, making it useful for dependent operations.
</Note>